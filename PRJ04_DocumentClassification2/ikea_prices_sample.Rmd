---
title: "IKEA prices"
author: "Esteban Aramayo"
date: '`r Sys.Date()`'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = TRUE, cache.lazy = FALSE, warning = FALSE,
                      message = FALSE, echo = TRUE, dpi = 180,
                      fig.width = 8, fig.height = 5)
library(tidyverse)
library(silgelib)

# If necessary run the 2 lines below to install the latest version of "silgelib" package
# install.packages("remotes")
# remotes::install_github("juliasilge/silgelib")

theme_set(theme_light())

```

Let's build a model for IKEA. We can build a model to predict prices from other furniture
characteristics lije category and size.

## Explore data

```{r}
ikea <- read_csv("https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-11-03/ikea.csv")
```

```{r}
ikea %>%
  select(X1, price, depth:width) %>%
  pivot_longer(depth:width, names_to = "dim") %>%
  ggplot(aes(value, price, color = dim)) +
  geom_point(alpha = 0.4, show.legend = FALSE) +
  scale_y_log10() +
  facet_wrap(~ dim, scales = "free_x") +
  labs(x = NULL)
```

Let's build a dataframe to be used for the model
```{r}
ikea_df <- ikea %>%
  select(price, name, category, depth, height, width) %>%
  mutate(price = log10(price)) %>%
  mutate_if(is.character, factor)
```



## Build a model

```{r}
library(tidymodels)
# if necessary install the "tidymodels" package
# install.packages("tidymodels")


set.seed(123)

# let's set up our experimental design by performing an initial split of our 
# data and stratify them by price (price is our outcome, which is what we are
# trying to predict)
ikea_split <- initial_split(ikea_df, strata = price)

# let's generate our training data from the initial split
ikea_train <- training(ikea_split)
ikea_test <- testing(ikea_split)

# let's do some re-sampling for comparing and tuning our models by using 
# bootstrap sampling (a.k.a "out-of-bag" (OOB) sampling)
set.seed(1234)
ikea_folds <- bootstraps(ikea_train, strata = price)
ikea_folds


```

Using functions from the "usemodels" package, let's do some code scaffolding 
for the "range random forest" model that we are going to use
```{r}
library(usemodels)
# if necessary install the "usemodels" package
# install.packages("usemodels")

# function below will generate prototype recipe code (boilerplate code) to 
# get us started with code that use best practices to train a ranger random
# forest model (the recipe code will be outputted to the console)
use_ranger(formula = price ~ ., data = ikea_train)

```


```{r}

library(doParallel)  # used to speed up backend execution of tune_grid
# if necessary install the "doParallel" package
# install.packages("doParallel")

library(textrecipes) # used to clean up the categorical data
# if necessary install the "textrecipes" package
# install.packages("textrecipes")

# set up the ranger recipe, but also perform the additional tasks below
# - using "step_other" try to collapse infrequently used name and category values to reduce their levels
# - using "step_clean_levels" clean up the name and category values by removing punctuation and spaces
# - using "step_knnimpute" immpute missing data (NA values) from nearest neighbors
ranger_recipe <- 
  recipes::recipe(formula = price ~ ., data = ikea_train) %>%
  recipes::step_other(name, category, threshold = 0.01) %>%
  textrecipes::step_clean_levels(name, category) %>%
  step_knnimpute(depth, height, width)

# model specification for tuning
ranger_spec <- 
  rand_forest(mtry = tune(), min_n = tune(), trees = 1000) %>% 
  set_mode("regression") %>% 
  set_engine("ranger") 

# set up a workflow that puts the recipe and the specification together
ranger_workflow <- 
  workflow() %>% 
  add_recipe(ranger_recipe) %>% 
  add_model(ranger_spec) 



# # set up the actual tuning, make sure you provide the resamples and 
# # the grid (how many candidate points to be tried)
# set.seed(8577)
# 
# start_time <- Sys.time()
# 
# # add a parallel backend to execute tune_grid faster by using multiple available CPU cores
# # execution times recorded:
# #   without it:  9.394061 mins
# #   With it   : 16.876190 secs  (makes a huge difference)
# doParallel::registerDoParallel()  
# 
# # code below seems to rely on presence of "janitor" package
# # install.packages("janitor")
# # code below seems to rely on presence of "ranger" package
# # install.packages("ranger")
# ranger_tune <-
#   tune_grid(ranger_workflow,
#             resamples = ikea_folds,
#             grid = 11)
# 
# end_time <- Sys.time()
# end_time - start_time


```

```{r}

# set up the actual tuning, make sure you provide the resamples and 
# the grid (how many candidate points to be tried)
set.seed(8577)

start_time <- Sys.time()

# add a parallel backend to execute tune_grid faster by using multiple available CPU cores
# execution times recorded:
#   without it:  9.394061 mins
#   With it   : 16.876190 secs  (makes a huge difference)
doParallel::registerDoParallel()  

# code below seems to rely on presence of "janitor" package
# install.packages("janitor")
# code below seems to rely on presence of "ranger" package
# install.packages("ranger")
ranger_tune <-
  tune_grid(ranger_workflow,
            resamples = ikea_folds,
            grid = 11)

end_time <- Sys.time()
end_time - start_time

all_cores <- parallel::detectCores(logical = FALSE)
#library(doParallel)
cl <- parallel::makePSOCKcluster(all_cores)
doParallel::registerDoParallel(cl)

set.seed(8577)
lasso_grid <- tune_grid(
  lasso_wf,
  resamples = review_folds,
  grid = lambda_grid,
  metrics = metric_set(roc_auc, ppv, npv),
  control = control_grid(pkgs = c('textrecipes'))
)

```




## Explore results

Let's look at the best performing models by looking at the tune results

```{r}
show_best(ranger_tune, metric = "rmse")
show_best(ranger_tune, metric = "rsq")

```

Let's plot the results

```{r}
autoplot(ranger_tune)
```






